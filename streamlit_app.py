# streamlit_app.py
import json
import requests
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
import matplotlib as mpl
import textwrap
import os
import urllib.request
import json as _json
from collections import Counter, defaultdict
from datetime import datetime, timezone
from datetime import timedelta

# ---------------- Custom CSS for Mobile UI/Card Style ----------------
def load_css():
    st.markdown("""
        <style>
        /* 1. Mobile-friendly: Reduce padding around main content */
        .block-container {
            padding-top: 2rem;
            padding-bottom: 2rem;
            padding-left: 1rem !important;
            padding-right: 1rem !important;
        }
        
        /* 2. Style for Question Card */
        .stQuestionCard {
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.05);
            background-color: #ffffff;
        }

        /* 3. Reduce vertical space (st.divider) in form */
        div[data-testid="stDivider"] {
            margin-top: 5px;
            margin-bottom: 10px;
        }
        
        /* 4. Make radio buttons more visually distinct (REDUCED PADDING) */
        div[data-testid*="stRadio"] label {
            padding: 4px 8px; /* ‡∏•‡∏î padding ‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å 10px ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 8px */
            border-radius: 8px;
            margin: 1px; /* ‡∏•‡∏î margin */
            transition: background-color 0.1s;
            text-align: center;
        }
        /* Highlight selected option */
        div[data-testid*="stRadio"] label[data-baseweb="radio"]:has(input:checked) {
            background-color: #e6f7ff;
            border-left: 3px solid var(--primary-color);
        }

        /* 5. Reduce font size for st.metric values (time) */
        div[data-testid="stMetricValue"] {
            font-size: 1.2rem;
            line-height: 1.4;
        }

        /* 6. ENHANCEMENT: Force Radio Options to fit horizontally (REDUCED GAP/FLEX) */
        /* Targets the container holding the radio options */
        div[data-testid*="stRadio"] > div {
            display: flex;
            flex-wrap: wrap; 
            gap: 3px; /* ‡∏•‡∏î‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å 5px ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 3px */
            justify-content: space-between; /* ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å */
        }
        /* Ensure each option is a flex item */
        div[data-testid*="stRadio"] label {
            flex-grow: 1; /* ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà */
            flex-shrink: 1; /* ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏´‡∏î‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ */
            min-width: 0; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ */
        }
        </style>
        """, unsafe_allow_html=True)

# ---------------- Timezone Helper ----------------
def utc_to_ict(utc_iso_string: str) -> str:
    """Converts a UTC ISO string to ICT (UTC+7) formatted string."""
    try:
        # 1. Parse UTC time
        dt_utc = datetime.fromisoformat(utc_iso_string.replace('Z', '+00:00'))
        # 2. Add 7 hours for ICT
        dt_ict = dt_utc + timedelta(hours=7)
        # 3. Format as a readable string (‡∏ï‡∏±‡∏î‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏≠‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡πÉ‡∏™‡πà ICT)
        return dt_ict.strftime("%Y-%m-%d %H:%M ‡∏ô. ICT") # 2025-10-27 00:30 ‡∏ô. ICT
    except Exception:
        return utc_iso_string # Return original string on error

# ---------------- Fonts (Thai) ----------------
# ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÉ‡∏ä‡πâ TH Sarabun New ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå (‡πÄ‡∏ä‡πà‡∏ô thsarabunnew-webfont.ttf)
try:
    if os.path.exists("thsarabunnew-webfont.ttf"):
        mpl.font_manager.fontManager.addfont("thsarabunnew-webfont.ttf")
        mpl.rc("font", family="TH Sarabun New", size=20)
    else:
        # fallback ‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ó‡∏¢‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏û‡∏≠‡∏Ñ‡∏ß‡∏£‡∏ö‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏∞‡∏ö‡∏ö
        plt.rcParams["font.family"] = "Tahoma"
        mpl.rc("font", family="DejaVu Sans", size=12)
except Exception:
    plt.rcParams["font.family"] = "DejaVu Sans"

plt.rcParams["axes.unicode_minus"] = False

# ---------------- Page Config (‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô Wide Mode ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Mobile UI) ----------------
# ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≤‡∏Å layout="centered" ‡πÄ‡∏õ‡πá‡∏ô layout="wide"
st.set_page_config(page_title="MCQ Answer Sheet", page_icon="üìù", layout="wide")

# ---------------- Secrets / Config ----------------
GAS_WEBAPP_URL = st.secrets.get("gas", {}).get("webapp_url", "").strip()
TEACHER_KEY    = st.secrets.get("app", {}).get("teacher_key", "").strip()
TIMEOUT        = 25

# ---------------- GAS Helpers ----------------
def gas_get(action: str, params: dict | None = None):
    if not GAS_WEBAPP_URL:
        # ‡πÉ‡∏ä‡πâ RuntimeError ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
        raise RuntimeError("GAS_WEBAPP_URL is not set.")
    url = f"{GAS_WEBAPP_URL}?action={action}"
    if params:
        for k, v in params.items():
            # ‡πÉ‡∏ä‡πâ requests.utils.quote ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå URL
            url += f"&{k}={requests.utils.quote(str(v))}"
    
    # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏î‡∏µ‡∏ö‡∏±‡∏Å URL ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    # print(f"GAS GET URL: {url}")
    
    r = requests.get(url, timeout=TIMEOUT)
    ct = r.headers.get("Content-Type", "")
    body_preview = (r.text or "")[:800]
    
    if r.status_code != 200:
        raise RuntimeError(f"GAS HTTP {r.status_code} ({ct}) ‚Äî {body_preview}")
    try:
        return r.json()
    except Exception:
        raise RuntimeError(f"GAS ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà JSON ({ct}) ‚Äî ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: {body_preview}")

def gas_post(action: str, payload: dict):
    if not GAS_WEBAPP_URL:
        raise RuntimeError("GAS_WEBAPP_URL is not set.")
    url = f"{GAS_WEBAPP_URL}?action={action}"
    r = requests.post(url, json=payload, timeout=30)
    ct = r.headers.get("Content-Type", "")
    body_preview = (r.text or "")[:800]
    if r.status_code != 200:
        raise RuntimeError(f"GAS HTTP {r.status_code} ({ct}) ‚Äî {body_preview}")
    try:
        return r.json()
    except Exception:
        raise RuntimeError(f"GAS ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà JSON ({ct}) ‚Äî ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: {body_preview}")

# ---------------- Routing (via ?mode=...) ----------------
raw_mode = st.query_params.get("mode", "exam")
if isinstance(raw_mode, list) and raw_mode:
    raw_mode = raw_mode[0]
mode = str(raw_mode).strip().lower()

# ----------------------------------------------------------------------
# ====================== Student Page ======================
# ----------------------------------------------------------------------

def is_within_window(start_utc: str, end_utc: str) -> tuple[bool, str]:
    try:
        if not start_utc or not end_utc:
            # ‡∏ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á = ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤
            return True, "‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤"
        now = datetime.now(timezone.utc)
        start = datetime.fromisoformat(start_utc.replace("Z", "+00:00"))
        end   = datetime.fromisoformat(end_utc.replace("Z", "+00:00"))
        if now < start:
            return False, f"‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≠‡∏ö (‡πÄ‡∏£‡∏¥‡πà‡∏° {start_utc})"
        if now > end:
            return False, f"‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏≥‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß (‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î {end_utc})"
        return True, ""
    except Exception as e:
        # ‡∏ñ‡πâ‡∏≤‡∏û‡∏≤‡∏£‡πå‡∏™‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ú‡πà‡∏≤‡∏ô (‡πÑ‡∏°‡πà‡∏•‡πá‡∏≠‡∏Å) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        return True, f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏î‡πâ ({e})"

def page_exam():
    load_css()
    st.markdown("### üìù ‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏©‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö MCQ Resident ER-Rajavithi")
    if not GAS_WEBAPP_URL:
        st.warning("‚ö†Ô∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ [gas.webapp_url] ‡πÉ‡∏ô Secrets ‡∏Å‡πà‡∏≠‡∏ô")
        return

    # 1) ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö
    try:
        js = gas_get("get_active_exam")
        if not js.get("ok"):
            # --------------------- START FIX/DEBUGGING ---------------------
            st.error("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏≠‡∏¢‡∏π‡πà (Active Exam) ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
            st.info("‡πÉ‡∏´‡πâ‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡πÑ‡∏õ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤ Dashboard")
            st.subheader("‚ö†Ô∏è Response ‡∏à‡∏≤‡∏Å GAS (Debug)")
            st.write("‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏µ‡∏¢‡πå **'ok'** ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô **true** ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ñ‡∏µ‡∏¢‡πå **'data'** ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà")
            st.json(js)
            # --------------------- END FIX/DEBUGGING ---------------------
            return
        exam = js["data"]
    except Exception as e:
        st.error(f"‡πÇ‡∏´‡∏•‡∏î‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
        # --------------------- START FIX/DEBUGGING ---------------------
        st.subheader("‚ö†Ô∏è Exception ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (GAS/Network Error)")
        st.exception(e)
        # --------------------- END FIX/DEBUGGING ---------------------
        return

    qn = int(exam.get("question_count", 0))
    exam_id = exam.get("exam_id", "")
    st.info(f"‡∏ä‡∏∏‡∏î: **{exam_id}** ‚Ä¢ {exam.get('title','')} ‚Ä¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô **{qn}** ‡∏Ç‡πâ‡∏≠ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å A‚ÄìE)") # ‡πÄ‡∏ô‡πâ‡∏ô‡∏ï‡∏±‡∏ß‡∏´‡∏ô‡∏≤

    # 2) ‡∏ï‡∏£‡∏ß‡∏à‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ (‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏õ‡∏¥‡∏î‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á)
    time_mode_raw = (exam.get("time_mode", "") or "").strip().lower()
    window_start  = exam.get("window_start_utc", "") or ""
    window_end    = exam.get("window_end_utc", "") or ""

    has_window = bool(window_start and window_end)
    ok_time, msg_time = is_within_window(window_start, window_end)
    
    # --------------------- START UI Enhancement ---------------------
    
    if has_window:
        # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤ UTC ‡πÄ‡∏õ‡πá‡∏ô ICT ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
        ict_start = utc_to_ict(window_start)
        ict_end = utc_to_ict(window_end)
        
        # ‡πÉ‡∏ä‡πâ Container ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏∏‡πâ‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏´‡πâ‡πÇ‡∏î‡∏î‡πÄ‡∏î‡πà‡∏ô
        with st.container(border=True):
            st.markdown("### ‚è∞ ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≠‡∏ö")
            
            col_start, col_end = st.columns(2)
            
            with col_start:
                st.metric(label="‚úÖ ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", value=ict_start)
            with col_end:
                st.metric(label="üõë ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î", value=ict_end)
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏≠‡∏¢‡∏π‡πà/‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤)
            if not ok_time:
                st.error(f"‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: {msg_time} üö´")
            else:
                st.success("‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≠‡∏ö ‚úÖ")


    if has_window and not ok_time:
        # ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤
        # st.error(f"‚è∞ {msg_time}") # ‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô Container
        # st.info(f"‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≠‡∏ö (‡πÑ‡∏ó‡∏¢): **{ict_start}** ‚Üí **{ict_end}**") # ‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô Container
        return # üîí ‡∏õ‡∏¥‡∏î‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏ó‡∏±‡∏ô‡∏ó‡∏µ: ‡πÑ‡∏°‡πà render ‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á

    # --------------------- END UI Enhancement ---------------------

    # 3) ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô baseline ‡πÄ‡∏î‡∏¥‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏õ (‡∏ü‡∏≠‡∏£‡πå‡∏° + ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö)
    # ... ‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ...
    elif has_window:
        st.caption(f"üïí ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≠‡∏ö : {ict_start} ‚Üí {ict_end}")

    # 3) ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô baseline ‡πÄ‡∏î‡∏¥‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏õ (‡∏ü‡∏≠‡∏£‡πå‡∏° + ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö)
    ss = st.session_state
    ss.setdefault("submitted", False)
    ss.setdefault("pending_submit_payload", None)
    ss.setdefault("submit_result", None)
    ss.setdefault("submit_error", None)
    ss.setdefault("answers", [""] * qn)

    if ss["submit_result"] is not None:
        ss["submitted"] = True

    is_pending = ss["pending_submit_payload"] is not None
    disabled_all = ss["submitted"] or is_pending

    with st.form("exam_form", clear_on_submit=False):
        name = st.text_input("‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ö", placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠-‡∏™‡∏Å‡∏∏‡∏•", disabled=disabled_all)

        options = ["A", "B", "C", "D", "E"]
        if len(ss["answers"]) != qn:
            ss["answers"] = [""] * qn

        for i in range(qn):
            current = ss["answers"][i]
            choice = st.radio(
                f"‡∏Ç‡πâ‡∏≠ {i+1}",
                options=[""] + options,
                index=([""] + options).index(current) if current in ([""] + options) else 0,
                horizontal=True,
                disabled=disabled_all,
                key=f"q_{i+1}_radio_form",
            )
            ss["answers"][i] = choice
            st.divider()

        submitted_form = st.form_submit_button(
            "‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö",
            type="primary",
            use_container_width=True,
            disabled=disabled_all,
        )

    if submitted_form and not ss["submitted"]:
        if not name.strip():
            ss["submit_error"] = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠"
        else:
            ss["submit_error"] = None
            ss["pending_submit_payload"] = {
                "exam_id": exam_id,
                "student_name": name.strip(),
                "answers": ss["answers"],
            }

    if ss["pending_submit_payload"] is not None:
        with st.spinner("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö..."):
            try:
                js2 = gas_post("submit", ss["pending_submit_payload"])
                if js2.get("ok"):
                    ss["submit_result"] = js2["data"]
                    ss["submitted"] = True
                    ss["submit_error"] = None
                else:
                    err = js2.get("error") or "‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à"
                    ss["submit_error"] = err
                    ss["submitted"] = (err == "DUPLICATE_SUBMISSION")
            except Exception as e:
                ss["submit_error"] = f"‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}"
                ss["submitted"] = False
            finally:
                ss["pending_submit_payload"] = None
        st.rerun()

    if ss["submit_error"]:
        st.error(ss["submit_error"])

    if ss["submit_result"]:
        res = ss["submit_result"]
        st.success(f"‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚úÖ ‡πÑ‡∏î‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô {res['score']} / {qn} ({res['percent']}%)")
        with st.expander("‡∏î‡∏π‡πÄ‡∏â‡∏•‡∏¢‡∏£‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠ / ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå"):
            df = pd.DataFrame(res["detail"])
            df["status"] = df["is_correct"].map({True: "‡∏ñ‡∏π‡∏Å", False: "‡∏ú‡∏¥‡∏î"})
            df = df[["q", "ans", "correct", "status"]]
            df.columns = ["‡∏Ç‡πâ‡∏≠", "‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö", "‡πÄ‡∏â‡∏•‡∏¢", "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"]
            st.dataframe(df, hide_index=True, use_container_width=True)

# ====================== Teacher Dashboard ======================
def page_dashboard():
    st.markdown("### üë©‚Äçüè´ Dashboard ‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå ‚Äî ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Active Exam ‡πÅ‡∏•‡∏∞‡∏î‡∏π‡∏ú‡∏•")
    if not TEACHER_KEY:
        st.error("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡πÉ‡∏ô Secrets (app.teacher_key)")
        return

    key_in = st.text_input("‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå", type="password")
    if st.button("‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö", use_container_width=True) or key_in:
        if key_in != TEACHER_KEY:
            st.error("‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
            st.stop()
            return
        st.success("‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‚úÖ")

        # ‡πÇ‡∏´‡∏•‡∏î Config/Exams
        try:
            cfg = gas_get("get_config")
            if not cfg.get("ok"):
                st.error(cfg.get("error", "Config error"))
                # --------------------- START FIX/DEBUGGING ---------------------
                st.subheader("‚ö†Ô∏è Response Config (Debug)")
                st.json(cfg)
                # --------------------- END FIX/DEBUGGING ---------------------
                return
            exams = cfg["data"]["exams"]
            active_id = cfg["data"].get("active_exam_id", "")
        except Exception as e:
            st.error(f"‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            return

        if not exams:
            st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏ä‡∏µ‡∏ó 'Exams'")
            return

        # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö Active
        id_to_title = {e["exam_id"]: e["title"] for e in exams}
        options = [e["exam_id"] for e in exams]
        current_idx = options.index(active_id) if active_id in options else 0

        new_idx = st.selectbox(
            "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (Active)",
            options=list(range(len(options))),
            index=current_idx,
            format_func=lambda i: f"{options[i]} ‚Äî {id_to_title[options[i]]}",
        )
        
        # üìå FIX: chosen_id ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÑ‡∏ß‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ü‡∏≠‡∏£‡πå‡∏°
        chosen_id = options[new_idx] 
        current_exam = next((e for e in exams if e["exam_id"] == chosen_id), {})
        
        # ------------------- ‡∏™‡πà‡∏ß‡∏ô‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° Active Exam -------------------
        col1, col2 = st.columns([1, 1])
        with col1:
            if st.button("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô Active Exam", type="primary", use_container_width=True):
                # ... ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Active Exam ‡πÄ‡∏î‡∏¥‡∏° ...
                try:
                    js = gas_post("set_active_exam", {"exam_id": chosen_id, "teacher_key": TEACHER_KEY})
                    if js.get("ok"):
                        st.success(f"‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Active Exam ‡πÄ‡∏õ‡πá‡∏ô {chosen_id} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")
                    elif js.get("error") == "UNAUTHORIZED":
                        st.error("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï (‡∏ï‡∏£‡∏ß‡∏à TEACHER_KEY ‡πÉ‡∏ô‡∏ä‡∏µ‡∏ó Config ‡∏Ç‡∏≠‡∏á GAS)")
                    else:
                        st.error(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {js.get('error')}")
                except Exception as e:
                    st.error(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
        with col2:
            st.caption(f"‡∏ä‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ: **{active_id or '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á'}**")
        
        st.subheader("‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏ä‡∏∏‡∏î‡∏ô‡∏µ‡πâ")
        try:
            jsr = gas_get("get_dashboard", {"exam_id": chosen_id})
            if not jsr.get("ok"):
                st.error(jsr.get("error", "Unknown error"))
                return
            records = jsr["data"]
            if not records:
                st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏ä‡∏∏‡∏î‡∏ô‡∏µ‡πâ")
                return

            df = pd.DataFrame(records)
            if "timestamp" in df.columns:
                df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
                df = df.sort_values("timestamp", ascending=True)

            # ‡πÉ‡∏ä‡πâ Expander ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ú‡∏•
            with st.expander("üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏£‡∏≤‡∏¢‡∏Ñ‡∏ô (‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î)", expanded=False):
                show = df[["timestamp", "student_name", "score", "percent", "answers"]].copy()
                show.columns = ["‡πÄ‡∏ß‡∏•‡∏≤", "‡∏ä‡∏∑‡πà‡∏≠", "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô", "‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå", "‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö"]
                st.dataframe(show, hide_index=True, use_container_width=True)
            
            st.subheader("‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏ß‡∏°")
            avg = float(df["percent"].astype(float).mean())
            best = int(df["percent"].astype(float).max())
            worst = int(df["percent"].astype(float).min())
            st.write(f"**‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢:** {avg:.1f}% | **‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î:** {best}% | **‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î:** {worst}%")

            # === ‡∏Å‡∏£‡∏≤‡∏ü‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ (‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô) - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á UI ===
            
            plot_df = df[["student_name", "percent"]].copy()
            plot_df["student_name"] = plot_df["student_name"].astype(str).str.strip()

            def wrap_label(s, width=10):
                return "\n".join(textwrap.wrap(s, width=width))

            plot_df["label"] = plot_df["student_name"].apply(lambda s: wrap_label(s, width=10))
            plot_df = plot_df.sort_values("percent", ascending=True)

            with st.container(border=True):
                st.markdown("##### ‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏≤‡∏¢‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•")
                fig, ax = plt.subplots(figsize=(10, max(3, 0.6 * len(plot_df))))
                
                # --- UI Style Enhancement ---
                ax.barh(plot_df["label"], plot_df["percent"], color='#4c96d7', height=0.7) # Custom color (Blue)
                ax.set_xlim(0, 100)
                ax.set_xlabel("‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå", fontsize=12)
                ax.set_ylabel("‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", fontsize=12)
                ax.set_title(f"‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (%) ‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô ‚Ä¢ {chosen_id}", fontsize=14, pad=12)
                ax.tick_params(axis="both", labelsize=12)
                ax.grid(axis='x', linestyle='--', alpha=0.6) # ‡πÄ‡∏û‡∏¥‡πà‡∏° Grid ‡πÅ‡∏Å‡∏ô X
                ax.spines['right'].set_visible(False) # ‡∏ã‡πà‡∏≠‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏ß‡∏≤
                ax.spines['top'].set_visible(False) # ‡∏ã‡πà‡∏≠‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≠‡∏ö‡∏ö‡∏ô
                # --- End UI Style Enhancement ---
                
                for i, v in enumerate(plot_df["percent"].to_list()):
                    ax.text(v + 1, i, f"{int(v)}%", va="center", fontsize=11, color='#4c96d7')
                plt.tight_layout()
                st.pyplot(fig, use_container_width=True)

            # ======================= Item Analysis =======================
            # ... ‡πÇ‡∏Ñ‡πâ‡∏î‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Item Analysis ‡πÄ‡∏î‡∏¥‡∏° ...
            from collections import Counter
            import json as _json

            answers_lists = []
            if "answers" in df.columns:
                for s in df["answers"].astype(str).fillna(""):
                    arr = [a.strip().upper() for a in s.split(",")]
                    arr = [a for a in arr if a]
                    answers_lists.append(arr)
            else:
                answers_lists = []

            total = len(answers_lists)
            first_detail = None
            if "detail" in df.columns:
                for v in df["detail"]:
                    try:
                        d = v if isinstance(v, list) else _json.loads(v) if isinstance(v, str) else None
                        if isinstance(d, list) and len(d) > 0:
                            first_detail = d
                            break
                    except Exception:
                        pass
            qn_detail = len(first_detail) if isinstance(first_detail, list) else 0

            answer_key = None
            if isinstance(first_detail, list):
                answer_key = [str(x.get("correct","")).strip().upper() if isinstance(x, dict) else "" for x in first_detail]

            if answer_key is None:
                try:
                    ex = gas_get("get_active_exam")
                    if ex.get("ok") and str(ex["data"].get("exam_id","")) == str(chosen_id):
                        k = str(ex["data"].get("answer_key","") or "")
                        answer_key = [c.strip().upper() for c in list(k)]
                except Exception:
                    pass
            key_len = len(answer_key) if isinstance(answer_key, list) else 0

            lens = [len(a) for a in answers_lists]
            maj_len = Counter(lens).most_common(1)[0][0] if lens else 0

            candidates = [x for x in [maj_len, qn_detail, key_len] if x and x > 0]
            qn = min(candidates) if candidates else 0

            if qn == 0 or total == 0:
                st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö/‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠")
            else:
                answers_lists = [arr[:qn] for arr in answers_lists]
                if isinstance(answer_key, list):
                    answer_key = answer_key[:qn]

                option_counts = [Counter() for _ in range(qn)]
                valid_opts = ["A", "B", "C", "D", "E"]
                for arr in answers_lists:
                    for i in range(qn):
                        opt = arr[i].upper() if i < len(arr) else ""
                        opt = opt if opt in valid_opts else "(blank)"
                        option_counts[i][opt] += 1

                if isinstance(answer_key, list) and any(answer_key):
                    correct_counts = [0] * qn
                    for arr in answers_lists:
                        for i in range(qn):
                            stu = arr[i].upper() if i < len(arr) else ""
                            key = answer_key[i] if i < len(answer_key) else ""
                            if stu and key and (stu == key):
                                correct_counts[i] += 1
                    wrong_counts = [total - c for c in correct_counts]
                    perc_correct = [round((c * 100) / total) if total > 0 else 0 for c in correct_counts]

                    item_df = pd.DataFrame({
                        "‡∏Ç‡πâ‡∏≠": [i + 1 for i in range(qn)],
                        "‡πÄ‡∏â‡∏•‡∏¢": answer_key,
                        "‡∏ñ‡∏π‡∏Å(‡∏Ñ‡∏ô)": correct_counts,
                        "‡∏ú‡∏¥‡∏î(‡∏Ñ‡∏ô)": wrong_counts,
                        "%‡∏ñ‡∏π‡∏Å": perc_correct,
                    })

                    # ‡πÉ‡∏ä‡πâ Expander ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö Item Analysis
                    with st.expander("‚úÖ Item Analysis ‚Äî ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å‡∏£‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠", expanded=True):
                        st.dataframe(item_df, hide_index=True, use_container_width=True)

                        # ‡∏Å‡∏£‡∏≤‡∏ü % ‡∏ñ‡∏π‡∏Å (‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏¢‡∏≤‡∏Å‚Üí‡∏á‡πà‡∏≤‡∏¢)
                        plot1 = item_df.sort_values("%‡∏ñ‡∏π‡∏Å", ascending=True)
                        fig1, ax1 = plt.subplots(figsize=(10, max(3.5, 0.55 * len(plot1))))
                        
                        # --- UI Style Enhancement ---
                        ax1.barh(plot1["‡∏Ç‡πâ‡∏≠"].astype(str), plot1["%‡∏ñ‡∏π‡∏Å"], color='#28a745', height=0.7) # Custom color (Green)
                        ax1.set_xlabel("% ‡∏ñ‡∏π‡∏Å", fontsize=14)
                        ax1.set_ylabel("‡∏Ç‡πâ‡∏≠", fontsize=14)
                        ax1.set_xlim(0, 100)
                        ax1.set_title("‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠ (‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏¢‡∏≤‡∏Å‡πÑ‡∏õ‡∏á‡πà‡∏≤‡∏¢)", fontsize=14, pad=12)
                        ax1.grid(axis='x', linestyle='--', alpha=0.6)
                        ax1.spines['right'].set_visible(False)
                        ax1.spines['top'].set_visible(False)
                        # --- End UI Style Enhancement ---
                        
                        for i, v in enumerate(plot1["%‡∏ñ‡∏π‡∏Å"].tolist()):
                            ax1.text(v + 1, i, f"{v}%", va="center", fontsize=12, color='#28a745')
                        plt.tight_layout()
                        st.pyplot(fig1, use_container_width=True)

                        hardest = plot1.iloc[0]
                        st.caption(f"üîé ‡∏Ç‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ú‡∏¥‡∏î‡πÄ‡∏¢‡∏≠‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î: **‡∏Ç‡πâ‡∏≠ {hardest['‡∏Ç‡πâ‡∏≠']}** (‡∏ñ‡∏π‡∏Å {hardest['%‡∏ñ‡∏π‡∏Å']}%)")
                else:
                    # 9) ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏â‡∏•‡∏¢ ‚Üí ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏£‡∏≤‡∏ü distribution ‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠ (A‚ÄìE/‡πÄ‡∏ß‡πâ‡∏ô‡∏ß‡πà‡∏≤‡∏á)
                    st.subheader("üìå Item Analysis ‚Äî ‡πÅ‡∏à‡∏Å‡πÅ‡∏à‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠ (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡πÄ‡∏â‡∏•‡∏¢)")
                    dist_df = []
                    all_opts = ["A", "B", "C", "D", "E", "(blank)"]
                    for i, cnt in enumerate(option_counts, start=1):
                        row = {"‡∏Ç‡πâ‡∏≠": i}
                        for o in all_opts:
                            row[o] = cnt.get(o, 0)
                        dist_df.append(row)
                    dist_df = pd.DataFrame(dist_df)

                    with st.expander("üìä ‡πÅ‡∏à‡∏Å‡πÅ‡∏à‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠ (‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π)", expanded=True):
                        st.dataframe(dist_df, hide_index=True, use_container_width=True)

                        # ‡∏Å‡∏£‡∏≤‡∏ü stacked distribution
                        figd, axd = plt.subplots(figsize=(10, max(3.5, 0.55 * len(dist_df))))
                        y = dist_df["‡∏Ç‡πâ‡∏≠"].astype(str)
                        left = [0] * len(dist_df)
                        
                        # --- UI Style Enhancement: ‡πÉ‡∏ä‡πâ‡∏ä‡∏∏‡∏î‡∏™‡∏µ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô ---
                        colors = ['#FF9999', '#99CCFF', '#99FF99', '#FFFF99', '#CC99FF', '#DDDDDD'] # Pastel/Soft colors
                        color_map = {opt: colors[i % len(colors)] for i, opt in enumerate(all_opts)}
                        
                        for i, o in enumerate(all_opts):
                            vals = dist_df[o].tolist()
                            axd.barh(y, vals, left=left, label=o, color=color_map[o], edgecolor='grey')
                            left = [l + v for l, v in zip(left, vals)]
                        
                        axd.set_xlabel("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", fontsize=12)
                        axd.set_ylabel("‡∏Ç‡πâ‡∏≠", fontsize=12)
                        axd.set_title("Distribution ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠ (A‚ÄìE/‡πÄ‡∏ß‡πâ‡∏ô‡∏ß‡πà‡∏≤‡∏á)", fontsize=14, pad=12)
                        axd.legend(loc="lower right", ncol=3, frameon=True)
                        axd.grid(axis='x', linestyle='--', alpha=0.6)
                        axd.spines['right'].set_visible(False)
                        axd.spines['top'].set_visible(False)
                        # --- End UI Style Enhancement ---
                        
                        plt.tight_layout()
                        st.pyplot(figd, use_container_width=True)

                        st.info("‚ÑπÔ∏è ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÄ‡∏â‡∏•‡∏¢ (answer_key) ‡∏à‡∏∂‡∏á‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ñ‡∏π‡∏Å/‡∏ú‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Ç‡πâ‡∏≠‡πÑ‡∏î‡πâ")
        except Exception as e:
            st.error(f"‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")

# ----------------------------------------------------------------------
# ====================== Run Main App ======================
# ----------------------------------------------------------------------

if mode == "dashboard":
    page_dashboard()
else:
    page_exam()
