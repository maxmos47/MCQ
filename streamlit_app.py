import json
import requests
import pandas as pd
import streamlit as st

st.set_page_config(page_title="MCQ Answer Sheet", page_icon="üìù", layout="centered")

GAS_WEBAPP_URL = st.secrets.get("gas", {}).get("webapp_url", "").strip()
TEACHER_KEY = st.secrets.get("app", {}).get("teacher_key", "").strip()
TIMEOUT = 25

def gas_get(action: str, params: dict | None = None):
    url = f"{GAS_WEBAPP_URL}?action={action}"
    if params:
        for k,v in params.items():
            url += f"&{k}={requests.utils.quote(str(v))}"
    r = requests.get(url, timeout=TIMEOUT)
    r.raise_for_status()
    return r.json()

def gas_post(action: str, payload: dict):
    url = f"{GAS_WEBAPP_URL}?action={action}"
    r = requests.post(url, json=payload, timeout=30)
    r.raise_for_status()
    return r.json()

# Robust query param
raw_mode = st.query_params.get("mode", "exam")
if isinstance(raw_mode, list) and raw_mode:
    raw_mode = raw_mode[0]
mode = str(raw_mode).strip().lower()

def fetch_exams():
    try:
        js = gas_get("get_config")
        if js.get("ok"):
            return js["data"]["exams"]
        else:
            st.error(js.get("error","Config error"))
    except Exception as e:
        st.error(f"‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
    return []

def fetch_exam(exam_id: str):
    try:
        js = gas_get("get_exam", {"exam_id": exam_id})
        if js.get("ok"):
            return js["data"]
        else:
            st.error(js.get("error","Exam error"))
    except Exception as e:
        st.error(f"‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
    return None

def page_exam():
    st.markdown("### üìù ‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏©‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö MCQ (‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠) ‚Äî ‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö")
    if not GAS_WEBAPP_URL:
        st.warning("‚ö†Ô∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ [gas.webapp_url] ‡πÉ‡∏ô Secrets ‡∏Å‡πà‡∏≠‡∏ô")
        return

    exams = fetch_exams()
    if not exams:
        st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏ä‡∏µ‡∏ó 'Exams'")
        return

    # Select exam set
    exam_titles = [f"{e['exam_id']} ‚Äî {e['title']}" for e in exams]
    idx = st.selectbox("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö", options=list(range(len(exams))), format_func=lambda i: exam_titles[i], index=0, disabled=st.session_state.get("submitted", False))
    selected_exam = exams[idx]
    exam_id = selected_exam["exam_id"]

    # Load specific exam details
    exam = fetch_exam(exam_id)
    if not exam: return
    qn = int(exam.get("question_count",0))
    correct = exam.get("correct_answers",[])

    # Name & check duplicate status
    name = st.text_input("‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ö", placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠-‡∏™‡∏Å‡∏∏‡∏•", disabled=st.session_state.get("submitted", False))
    colA, colB = st.columns([1,1])
    with colA:
        if st.button("‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏™‡πà‡∏á (‡πÄ‡∏ä‡πá‡∏Å‡∏ß‡πà‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏Ñ‡∏¢‡∏™‡πà‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏´‡∏°)", disabled=st.session_state.get("submitted", False)):
            if not name.strip():
                st.warning("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö")
            else:
                try:
                    chk = gas_get("check_submitted", {"exam_id": exam_id, "student_name": name.strip()})
                    if chk.get("ok") and chk["data"]["submitted"]:
                        st.session_state["submitted"] = True
                        st.info("‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ö‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏∏‡∏î‡∏ô‡∏µ‡πâ (‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥)")
                    else:
                        st.success("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏∏‡∏î‡∏ô‡∏µ‡πâ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡πÑ‡∏î‡πâ")
                except Exception as e:
                    st.error(f"‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
    with colB:
        if st.session_state.get("submitted", False):
            st.button("‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö (‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥‡πÅ‡∏•‡πâ‡∏ß)", disabled=True)

    st.info(f"‡∏ä‡∏∏‡∏î: {exam_id} ‚Ä¢ {exam.get('title','')} ‚Ä¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô {qn} ‡∏Ç‡πâ‡∏≠ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å A‚ÄìE)")
    options = ["A","B","C","D","E"]

    # Init answers & lock flag
    if "answers" not in st.session_state or len(st.session_state["answers"])!=qn:
        st.session_state["answers"] = [""]*qn
    if "submitted" not in st.session_state:
        st.session_state["submitted"] = False

    # Checkbox UI per question (mutually exclusive)
    for i in range(qn):
        st.markdown(f"**‡∏Ç‡πâ‡∏≠ {i+1}**")
        cols = st.columns(5, vertical_alignment="center")
        current = st.session_state["answers"][i]
        for j, label in enumerate(options):
            key = f"q{i+1}_{label}"
            checked = (current == label)
            cols[j].checkbox(label, value=checked, key=key, disabled=st.session_state["submitted"])
        # Enforce single choice
        selected = None
        for label in options:
            if st.session_state.get(f"q{i+1}_{label}"):
                selected = label if selected is None else selected
        if selected is not None:
            for label in options:
                if label != selected and st.session_state.get(f"q{i+1}_{label}"):
                    st.session_state[f"q{i+1}_{label}"] = False
        st.session_state["answers"][i] = selected or ""
        st.divider()

    # Submit (server-side duplicate lock by (exam_id, name))
    submit_disabled = st.session_state.get("submitted", False)
    if st.button("‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö", type="primary", use_container_width=True, disabled=submit_disabled):
        if not name.strip():
            st.warning("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠")
            return
        try:
            js = gas_post("submit", {"exam_id": exam_id, "student_name": name.strip(), "answers": st.session_state["answers"]})
            if js.get("ok"):
                res = js["data"]
                st.session_state["submitted"] = True
                st.success(f"‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚úÖ ‡πÑ‡∏î‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô {res['score']} / {qn} ({res['percent']}%)")
                with st.expander("‡∏î‡∏π‡πÄ‡∏â‡∏•‡∏¢‡∏£‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠ / ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå"):
                    df = pd.DataFrame(res["detail"])
                    df["status"] = df["is_correct"].map({True:"‡∏ñ‡∏π‡∏Å", False:"‡∏ú‡∏¥‡∏î"})
                    df = df[["q","ans","correct","status"]]
                    df.columns = ["‡∏Ç‡πâ‡∏≠","‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö","‡πÄ‡∏â‡∏•‡∏¢","‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"]
                    st.dataframe(df, hide_index=True, use_container_width=True)
            else:
                if js.get("error")=="DUPLICATE_SUBMISSION":
                    st.session_state["submitted"] = True
                    st.info("‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏™‡∏≠‡∏ö‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏∏‡∏î‡∏ô‡∏µ‡πâ (‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥)")
                else:
                    st.error(f"‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {js.get('error')}")
        except Exception as e:
            st.error(f"‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")

def page_dashboard():
    st.markdown("### üë©‚Äçüè´ Dashboard ‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå (‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö)")
    if not TEACHER_KEY:
        st.error("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå‡πÉ‡∏ô Secrets (app.teacher_key)")
        return
    key_in = st.text_input("‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏≤‡∏à‡∏≤‡∏£‡∏¢‡πå", type="password")
    if st.button("‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö", use_container_width=True) or key_in:
        if key_in != TEACHER_KEY:
            st.error("‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
            return
        st.success("‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‚úÖ")

        exams = fetch_exams()
        if not exams:
            st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏ä‡∏µ‡∏ó 'Exams'")
            return
        exam_titles = [f"{e['exam_id']} ‚Äî {e['title']}" for e in exams]
        idx = st.selectbox("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∏‡∏î‡∏Ç‡πâ‡∏≠‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏ú‡∏•", options=list(range(len(exams))), format_func=lambda i: exam_titles[i], index=0)
        exam_id = exams[idx]["exam_id"]
        st.caption(f"‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á‡∏ä‡∏∏‡∏î: {exam_id}")

        try:
            js = gas_get("get_dashboard", {"exam_id": exam_id})
            if not js.get("ok"):
                st.error(js.get("error","Unknown error"))
                return
            records = js["data"]
            if not records:
                st.info("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏ä‡∏∏‡∏î‡∏ô‡∏µ‡πâ")
                return

            df = pd.DataFrame(records)
            if "timestamp" in df.columns:
                df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
                df = df.sort_values("timestamp", ascending=True)

            st.subheader("‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏£‡∏≤‡∏¢‡∏Ñ‡∏ô")
            show = df[["timestamp","student_name","score","percent","answers"]].copy()
            show.columns = ["‡πÄ‡∏ß‡∏•‡∏≤","‡∏ä‡∏∑‡πà‡∏≠","‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô","‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå","‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö"]
            st.dataframe(show, hide_index=True, use_container_width=True)

            st.subheader("‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏ß‡∏°")
            avg = float(df["percent"].astype(float).mean())
            best = int(df["percent"].astype(float).max())
            worst = int(df["percent"].astype(float).min())
            st.write(f"‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢: {avg:.1f}% | ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: {best}% | ‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î: {worst}%")

            import matplotlib.pyplot as plt
            fig = plt.figure()
            plt.bar(df["student_name"], df["percent"])
            plt.xticks(rotation=45, ha="right")
            plt.ylabel("Percent")
            plt.title(f"‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (%) ‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô ‚Ä¢ {exam_id}")
            st.pyplot(fig, use_container_width=True)

            # Build correct answers from first record detail (they all same per exam)
            first_detail = df.iloc[0]["detail"] if "detail" in df.columns else None
            qn = len(first_detail) if first_detail else 0
            if qn>0:
                counts = [0]*qn
                total = len(df)
                for _, row in df.iterrows():
                    ans = [s.strip().upper() for s in str(row.get("answers","")).split(",")]
                    for i in range(qn):
                        if i < len(ans) and first_detail and ans[i] == first_detail[i]["correct"]:
                            counts[i] += 1
                perc = [ round((c*100)/total) if total>0 else 0 for c in counts ]
                item_df = pd.DataFrame({"‡∏Ç‡πâ‡∏≠": [i+1 for i in range(qn)], "%‡∏ñ‡∏π‡∏Å": perc})
                st.subheader("Item Analysis")
                st.dataframe(item_df, hide_index=True, use_container_width=True)

                fig2 = plt.figure()
                plt.plot(item_df["‡∏Ç‡πâ‡∏≠"], item_df["%‡∏ñ‡∏π‡∏Å"], marker="o")
                plt.xlabel("‡∏Ç‡πâ‡∏≠")
                plt.ylabel("% ‡∏ñ‡∏π‡∏Å")
                plt.title(f"Item Difficulty ‚Ä¢ {exam_id}")
                st.pyplot(fig2, use_container_width=True)

        except Exception as e:
            st.error(f"‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")

if mode == "dashboard":
    page_dashboard()
else:
    page_exam()
